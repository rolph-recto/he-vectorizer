use crate::lang::{*, ExprOperator::*, source::{*, IndexExpr::*, SourceExpr::*}};
use interval::{Interval, ops::Range};
use std::str::FromStr;

grammar;

pub Program: SourceProgram = {
    <inputs:InputList> <letBindings:LetNodeList> <expr:Expr> => SourceProgram { inputs, letBindings, expr },
    <letBindings:LetNodeList> <expr:Expr> => SourceProgram { inputs: im::Vector::new(), letBindings, expr },
    <inputs:InputList> <expr:Expr> => SourceProgram { inputs, letBindings: im::Vector::new(), expr },
    <expr:Expr> => SourceProgram { inputs: im::Vector::new(), letBindings: im::Vector::new(), expr }
}

InputList: im::Vector<InputNode> = {
    <il:InputList> <i:InputNode> => il + im::Vector::unit(i),
    <i:InputNode> => im::Vector::unit(i)
}

InputNode: InputNode = {
    "input" <arr:Ident> ":" "[" <e:ExtentList> "]" => InputNode(arr, e),
    "input" <arr:Ident> => InputNode(arr, im::Vector::new()),
}

LetNodeList: im::Vector<LetNode> = {
    <ll:LetNodeList> <l:LetNode> => ll + im::Vector::unit(l),
    <l:LetNode> => im::Vector::unit(l)
}   

LetNode: LetNode = {
    "let" <var:Ident> "=" <rhs:Expr> => {
        LetNode(var, Box::new(rhs))
    },
}

Expr: SourceExpr = {
    <e:AddSubExpr> => e,
    <e:MulExpr> => e,
};

// factor grammar this way so multiplication is always lower
// in the parse tree than add or subtraction
AddSubExpr: SourceExpr = {
    <l:Expr> "+" <r:MulExpr> => OpNode(OpAdd, Box::new(l), Box::new(r)),
    <l:Expr> "-" <r:MulExpr> => OpNode(OpSub, Box::new(l), Box::new(r)),
}

MulExpr: SourceExpr = {
    <l:MulExpr> "*" <r:TermExpr> => OpNode(OpMul, Box::new(l), Box::new(r)),
    <t:TermExpr> => t
}

TermExpr: SourceExpr = {
    "(" <e:Expr> ")" => e,

    <n:Num> => LiteralNode(n),

    "for" <x:Ident> ":" <e:Extent> "{" <body:Expr> "}" => {
        ForNode(x, e, Box::new(body))
    },

    "sum" "(" <body:Expr> ")" => ReduceNode(OpAdd, Box::new(body)),

    "product" "(" <body:Expr> ")" => ReduceNode(OpMul, Box::new(body)),

    <ie:IndexingNode> => IndexingNode(ie.0, ie.1)
}

IndexingNode: (ArrayName, im::Vector<IndexExpr>) = {
    <i:Ident> => (i, im::Vector::new()),
    <ie:IndexingNode> "[" <i:IndexExpr> "]" => (ie.0, ie.1 + im::Vector::unit(i)),
}

IndexExpr: IndexExpr = {
    <e:IndexAddSubExpr> => e,
    <e:IndexMulExpr> => e,
}

IndexAddSubExpr: IndexExpr = {
    <l:IndexExpr> "+" <r:IndexMulExpr> => IndexOp(OpAdd, Box::new(l), Box::new(r)),
    <l:IndexExpr> "-" <r:IndexMulExpr> => IndexOp(OpSub, Box::new(l), Box::new(r)),
}

IndexMulExpr: IndexExpr = {
    <l:IndexMulExpr> "*" <r:IndexTermExpr> => IndexOp(OpMul, Box::new(l), Box::new(r)),
    <e:IndexTermExpr> => e,
}

IndexTermExpr: IndexExpr = {
    <var:Ident> => IndexVar(var),
    <n:Num> => IndexLiteral(n),
}

ExtentListOrEmpty: im::Vector<Extent> = {
    <el:ExtentList> => el,
    "" => im::Vector::new()
}

ExtentList: im::Vector<Extent> = {
    <el:ExtentList> "," <e:Extent> => el + im::Vector::unit(e),
    <e:Extent> => im::Vector::unit(e)
}

Extent: Extent = "(" <lb:Num> "," <ub:Num> ")" => Interval::new(lb, ub);

Ident: String = <s:r"[[:alpha:]][[:word:]]*"> => String::from(s);
Num: i64 = <s:r"[0-9]+"> => i64::from_str(s).unwrap();