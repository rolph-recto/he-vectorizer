use crate::lang::{*, Operator::*, source::{*, IndexExpr::*, SourceExpr::*}};
use interval::{Interval, ops::Range};
use std::str::FromStr;

grammar;

pub Program: SourceProgram = {
    <inputs:InputList> <let_bindings:LetBindingList> <expr:Expr> => SourceProgram { inputs, let_bindings, expr },
    <let_bindings:LetBindingList> <expr:Expr> => SourceProgram { inputs: im::Vector::new(), let_bindings, expr },
    <inputs:InputList> <expr:Expr> => SourceProgram { inputs, let_bindings: im::Vector::new(), expr },
    <expr:Expr> => SourceProgram { inputs: im::Vector::new(), let_bindings: im::Vector::new(), expr }
}

InputList: im::Vector<Input> = {
    <il:InputList> <i:Input> => il + im::Vector::unit(i),
    <i:Input> => im::Vector::unit(i)
}

Input: Input = {
    "input" <arr:Ident> ":" "[" <e:ExtentList> "]" => Input(arr, e),
    "input" <arr:Ident> => Input(arr, im::Vector::new()),
}

LetBindingList: im::Vector<LetBinding> = {
    <ll:LetBindingList> <l:LetBinding> => ll + im::Vector::unit(l),
    <l:LetBinding> => im::Vector::unit(l)
}   

LetBinding: LetBinding = {
    "let" <var:Ident> "=" <rhs:Expr> => {
        LetBinding(var, Box::new(rhs))
    },
}

Expr: SourceExpr = {
    <e:AddSubExpr> => e,
    <e:MulExpr> => e,
};

// factor grammar this way so multiplication is always lower
// in the parse tree than add or subtraction
AddSubExpr: SourceExpr = {
    <l:Expr> "+" <r:MulExpr> => ExprOp(Add, Box::new(l), Box::new(r)),
    <l:Expr> "-" <r:MulExpr> => ExprOp(Sub, Box::new(l), Box::new(r)),
}

MulExpr: SourceExpr = {
    <l:MulExpr> "*" <r:TermExpr> => ExprOp(Mul, Box::new(l), Box::new(r)),
    <t:TermExpr> => t
}

TermExpr: SourceExpr = {
    "(" <e:Expr> ")" => e,

    <n:Num> => Literal(n),

    "for" <x:Ident> ":" <e:Extent> "{" <body:Expr> "}" => {
        For(x, e, Box::new(body))
    },

    "sum" "(" <body:Expr> ")" => Reduce(Add, Box::new(body)),

    "product" "(" <body:Expr> ")" => Reduce(Mul, Box::new(body)),

    <ie:Indexing> => Indexing(ie.0, ie.1)
}

Indexing: (ArrayName, im::Vector<IndexExpr>) = {
    <i:Ident> => (i, im::Vector::new()),
    <ie:Indexing> "[" <i:IndexExpr> "]" => (ie.0, ie.1 + im::Vector::unit(i)),
}

IndexExpr: IndexExpr = {
    <e:IndexAddSubExpr> => e,
    <e:IndexMulExpr> => e,
}

IndexAddSubExpr: IndexExpr = {
    <l:IndexExpr> "+" <r:IndexMulExpr> => IndexOp(Add, Box::new(l), Box::new(r)),
    <l:IndexExpr> "-" <r:IndexMulExpr> => IndexOp(Sub, Box::new(l), Box::new(r)),
}

IndexMulExpr: IndexExpr = {
    <l:IndexMulExpr> "*" <r:IndexTermExpr> => IndexOp(Mul, Box::new(l), Box::new(r)),
    <e:IndexTermExpr> => e,
}

IndexTermExpr: IndexExpr = {
    <var:Ident> => IndexVar(var),
    <n:Num> => IndexLiteral(n),
}

ExtentListOrEmpty: im::Vector<Extent> = {
    <el:ExtentList> => el,
    "" => im::Vector::new()
}

ExtentList: im::Vector<Extent> = {
    <el:ExtentList> "," <e:Extent> => el + im::Vector::unit(e),
    <e:Extent> => im::Vector::unit(e)
}

Extent: Extent = "(" <lb:Num> "," <ub:Num> ")" => Interval::new(lb as i64, ub as i64);

Ident: String = <s:r"[[:alpha:]][[:word:]]*"> => String::from(s);
Num: isize = <s:r"[0-9]+"> => isize::from_str(s).unwrap();